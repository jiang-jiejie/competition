#include <stdio.h>
#include "net/robocup_ssl_client.h"
#include "visionProto/messages_robocup_ssl_detection.pb.h"
#include "visionProto/messages_robocup_ssl_geometry.pb.h"
#include "visionProto/messages_robocup_ssl_wrapper.pb.h"
#include "gcProto/ssl_gc_referee_message.pb.h"
#include "endMotor/MotorIK.h"
#include <windows.h>
#include <time.h>
#pragma comment( lib,"winmm.lib" )
#include "SDK2.1.7/Windows/c&c++/inc_of_c++/jkerr.h"
#include "SDK2.1.7/Windows/c&c++/inc_of_c++/jktypes.h"
#include "SDK2.1.7/Windows/c&c++/inc_of_c++/JAKAZuRobot.h"
#include <chrono>
#include <iostream>
#include <thread>
#include <mutex>
#define pi222 3.1415926
#define M_PI pi222
#define Deg2Rad (pi222/180)
#define Rad2Deg (180/pi222)
#include <vector>
#include <complex>

struct Point
{
    double x;
    double y;
    double t; // time
};
Point ballPos;
std::mutex mtx;
//std::ofstream outfile;

char cmd = 'H';

// 声明函数
void getReferee();
void getVision();
void Hit_Ball(JAKAZuRobot& demo, MotorIK& mkmotor, JointValue& jval, int dire);
double goAvalue(double ball_x, double ball_y, double posi_x, double posi_y);

// 机械臂离桌面的距离
#define Uplift_Z 240;

// 记分桶到乒乓球桌子边的x，y坐标
// 6分桶的位置
//static double Barrel_X = 640.0;
//static double Barrel_Y = 250.0;

// 4分桶的位置
//static double Barrel_X = 278.88;
//static double Barrel_Y = 563.88;

// 2分桶的位置
static double Barrel_X = 278.88;
static double Barrel_Y = 50.0;

//static double Barrel_X = 410.8;
//static double Barrel_Y = 381.2;

//8分桶的位置
//static double Barrel_X = 877.56;
//static double Barrel_Y = 170;

// 打球函数
void Hit_Ball(JAKAZuRobot& demo, MotorIK& mkmotor, JointValue& jvalH, int dire)
{
    // 8ms发一次数据，需要确保加速度不要超过限制，具体请查看API说明手册
    //double speed = 780;//8分
    //double speed = 750;//6分
    //double speed = 600;//4分
    double speed = 350;//2分
    // 左边击打
    //if (dire == 0)
    //{
    //    mkmotor.goToPos2(-100, 1, speed, false);
    //}
    //// 右边击打
    //else if (dire == 1)
    //{
    //    mkmotor.goToPos2(100, 1, speed, false);
    //}
    //Sleep(1000);
    // //末端电机回到起始位置
    //mkmotor.goToPos2(0, 1, 50, false);
}


double goAvalue(double ball_x, double ball_y, double posi_x, double posi_y)
{
    ball_y = fabs(ball_y);
    double run_x = 2740 - ball_x + posi_x;
    double run_y = ball_y + posi_y;
    double arctan = atan(run_y / run_x);

    return arctan * Rad2Deg;
}

int main()
{   //定义球的位置参数
    double pp_cos_x = 0;
    double pp_sin_y = 0;
    // 在线程中运行getVision()获得球信息
    std::thread t1(getVision);
    t1.detach();

    // 在线程中运行getReferee()获得球信息
    std::thread t2(getReferee);
    t2.detach();


    // 机器人初始化
    JAKAZuRobot demo;
    demo.login_in("192.168.1.112"); // 使用机器人LAN2口，其IP地址需要在图形化开发软件中进行设置。伺服控制需要用千兆网线连接。
    demo.power_on();    // 本体上电
    demo.enable_robot();  // 电机使能  

    // 末端电机初始化
    //MotorIK mkmotor;
    //mkmotor.ID = 1;                   // 电机ID 为1
    //mkmotor.reduceRatio = 10;         // 设置减速比
    //mkmotor.setSerial(5, 115200);     // 设置串口COM号，及波特率
    //mkmotor.start();

    //机器人运行到一个初始位置

    JointValue jval, jvalH;
    /*jval.jVal[0] = 0 * Deg2Rad;
    jval.jVal[1] = 0 * Deg2Rad;
    jval.jVal[2] = 90 * Deg2Rad;
    jval.jVal[3] = 90 * Deg2Rad;
    jval.jVal[4] = 90 * Deg2Rad;
    jval.jVal[5] = 0 * Deg2Rad;*/

    jval.jVal[0] = 0 * Deg2Rad;
    jval.jVal[1] = 0 * Deg2Rad;
    jval.jVal[2] = 90 * Deg2Rad;
    jval.jVal[3] = 90 * Deg2Rad;
    jval.jVal[4] = 90 * Deg2Rad;
    jval.jVal[5] = 90 * Deg2Rad;
    errno_t ret = ERR_SUCC;
    ret = demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);    //请确认空间不会发生碰撞

    /*jval.jVal[5] = 90 * Deg2Rad;
    ret = demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);*/

    // 末端电机准备
   /* mkmotor.goToPos2(0, 1, 50, false);*/

    // goA为打击角度
    double goA = 0;
    double Eangle = 0;

    std::cout << "ok, wait ball" << std::endl;
    while (cmd != 'e')
    {
        if (cmd != 'k' || cmd != 'K')
        {
            // 对机器人末端期望的姿态进行赋值
            // 末端坐标系原点定义在乒乓球柄与末端法兰轴线相交的位置
            // goA为打击前球拍反转的角度
            CartesianPose pos;
            mtx.lock();
            std::printf("-Ball POS=<%9.2f,%9.2f>\n", ballPos.x, ballPos.y);
            /*std::printf("-Ball POS=<%9.2f,%9.2f>\n", ballPos.x, ballPos.y);*/
            std::cout << "ok, wait ball" << std::endl;
            std::cout << cmd << std::endl;
            pos.tran.x = ballPos.x;
            pos.tran.y = ballPos.y + 15;
            mtx.unlock();
            pos.tran.z = Uplift_Z;   // 工具坐标系离桌面的距离

            if (pos.tran.y >= 0)   // 击打位置在左侧的球
            {
                // 调整击打角度
                goA = goAvalue(pos.tran.x + 20, pos.tran.y, Barrel_X, Barrel_Y);

                Eangle = goA * Deg2Rad;
                //重载
                pp_cos_x = cos(Eangle) * 20;
                pp_sin_y = sin(Eangle) * 20;

                pos.tran.x = pos.tran.x - pp_cos_x;
                pos.tran.y = pos.tran.y + pp_sin_y;

                pos.rpy.rx = (-90 + goA) * Deg2Rad;
                pos.rpy.ry = 90 * Deg2Rad;
                pos.rpy.rz = 0;

                if (jval.jVal[4] == -90 * Deg2Rad)
                {
                    jval.jVal[4] = 90 * Deg2Rad;
                    demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);
                }

                ret = demo.kine_inverse(&jval, &pos, &jvalH);
                if (ret == 0)
                {
                    jvalH.jVal[5] += 25 * Deg2Rad;
                    //demo.joint_move(&jvalH, MoveMode::ABS, FALSE, 3, 10, 0.1, nullptr);
                    demo.joint_move(&jvalH, MoveMode::ABS, TRUE, 1);
                }
                else if (ret == -4)
                {
                    std::cout << "逆解求解失败" << std::endl;
                }
                Sleep(1000);
                //Hit_Ball(demo, mkmotor, jvalH, 0);
                Sleep(2000);

                // 机械臂返回等待位置
                ret = demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);
               // mkmotor.goToPos2(0, 1, 50, false);
            }
            else if (pos.tran.y < 0)    // 击打右侧的球
            {
                // 调整击打角度
                goA = goAvalue(pos.tran.x + 20, pos.tran.y, Barrel_X, Barrel_Y);
                Eangle = goA * Deg2Rad;

                pp_cos_x = cos(Eangle) * 20;
                pp_sin_y = sin(Eangle) * 20;

                pos.tran.x = pos.tran.x - pp_cos_x;
                pos.tran.y = pos.tran.y - pp_sin_y;

                pos.rpy.rx = (90 - goA) * Deg2Rad;
                pos.rpy.ry = 90 * Deg2Rad;
                pos.rpy.rz = 0;

                if (jval.jVal[4] == 90 * Deg2Rad)
                {
                    jval.jVal[4] = -90 * Deg2Rad;
                    demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);
                }

                ret = demo.kine_inverse(&jval, &pos, &jvalH);
                if (ret == 0)
                {
                    jvalH.jVal[5] -= 25 * Deg2Rad;
                    //demo.joint_move(&jvalH, MoveMode::ABS, FALSE, 3, 10, 0.1, nullptr);
                    demo.joint_move(&jvalH, MoveMode::ABS, TRUE, 1);
                }
                else if (ret == -4)
                {
                    std::cout << "逆解求解失败" << std::endl;
                }
                Sleep(1000);
               // Hit_Ball(demo, mkmotor, jvalH, 1);
                Sleep(2000);

                // 机械臂返回等待位置
                ret = demo.joint_move(&jval, MoveMode::ABS, TRUE, 1);
                //mkmotor.goToPos2(0, 1, 50, false);
            }
            Sleep(4000);
        }
    }
    return 0;
}

// 将裁判消息转换为命令
char translateRefMsgs(Referee_Command command)
{
    switch (command)
    {
    case 0:
        cmd = 'H';
        break; // Halt
    case 1:
        cmd = 'S';
        break; // Stop
    case 2:
        cmd = ' ';
        break; // Normal start (Ready)
    case 8:
        cmd = 'k';
        break; // Kickoff Yellow
    case 9:
        cmd = 'K';
        break; // Kickoff Blue
    default:
        std::cout << "refereebox is fail !!!!! command : " << command << std::endl;
        cmd = 'H';
        break;
    }
    return cmd;
}

// 函数：持续接收裁判信息
void getReferee()
{
    RoboCupSSLClient client(10003, "224.5.23.1", "");
    client.open(true); // 打开客户端连接
    Referee packet;
    byte datagram[20000];
    while (true) {
        if (client.receive(packet)) {
            if (packet.has_command()) { // 检查是否有命令
                Referee_Command next_command = packet.command();
                char cmd = translateRefMsgs(next_command); // 将命令转换为控制字符
                std::cout << "comand is******************* " << cmd; // 输出命令
                if (cmd == 'k' && packet.has_yellow())
                {
                    std::cout << "comand is " << cmd; // 输出命令
                    Referee_TeamInfo team = packet.yellow();
                    std::cout << "current hit num is " << team.timeouts(); //输出当前的击打数
                }
                if (cmd == 'K' && packet.has_blue())
                {
                    std::cout << "comand is " << cmd; // 输出命令
                    Referee_TeamInfo team = packet.blue();
                    std::cout << "current hit num is " << team.timeouts();//输出当前的击打数
                }
            }
            if (packet.has_yellow())
            {
                Referee_TeamInfo team = packet.yellow();
                std::cout << "current score is " << team.score();//输出得分
            }
            if (packet.has_blue())
            {
                Referee_TeamInfo team = packet.blue();
                std::cout << "current score is " << team.score();//输出得分
            }
        }
    }
    return;
}

// 函数：持续接收视觉数据
void getVision()
{
    RoboCupSSLClient client;
    client.open(true); // 打开客户端连接
    SSL_WrapperPacket packet;
    std::vector<Point> ballP; // 存储球的位置历史记录

    while (true) {
        if (client.receive(packet)) {
            if (packet.has_detection()) { // 检查是否有检测到的数据
                SSL_DetectionFrame detection = packet.detection();
                int balls_n = detection.balls_size(); // 获取检测到的球的数量
                std::printf("-----Received Wrapper Packet---------------------------------------------\n");
                // 更新球的位置
                for (int i = 0; i < balls_n; i++) {
                    SSL_DetectionBall ball = detection.balls(i);
                    Point pp;
                    pp.x = ball.x() - 20; // 调整 x 位置，减去 20 个单位
                    pp.y = ball.y();
                    pp.t = (detection.t_capture() / 10 - (int)(detection.t_capture() / 10)); // 计算时间信息
                    mtx.lock(); // 加锁以确保线程安全
                    ballPos = pp; // 更新全局的球位置
                    mtx.unlock(); // 解锁

                    ballP.push_back(pp); // 将球的位置添加到历史记录中
                    if (pp.x < 300) // 如果球的位置接近（x 坐标小于 300），记录数据
                    {
                        for (auto ball2 : ballP)
                        {
                            //outfile << ball2.x << "," << ball2.y << "," << ball2.t << '\n'; // 将球的位置和时间写入文件
                        }
                        //outfile.close(); // 关闭文件
                    }
                }
            }
        }
    }
    return;
}
